Гоша Дударь Изучение ASP.NET Core MVC / 

1 Age----------------------------------------------
ASP.Net платформа для разработки Web-проектов, он более скоростной, чем скриптовые языки, так как основа компилируется и передается на ПК в момент подключения к сайту, а все последующие переходы по сайту используют кэшированный код, который просто извлекается из памяти, а не скачивается с сервера повторно (экономит время на парсинге, загрузке и обработке файлов).
Ресурсы на ASP.Net:
StackOverflow (один из самых крупных форумов)
Основной сайт Майкрософт
GoDaddy (крупнейший сайт для регистрации доменов)
Офф. сайт DELL

В ASP.Net применяется шаблон MVC (model - view - controller)
Пользователь запускает процесс регистрации и отправляет на сервер регистрационные данные,
контроллер интерпретирует действия человека и передает модели информацию о внесенных изменениях
в статус пользователя, модель реагирует на действия контроллера и работает с поставленными данными.
Вид - отвечает за отображжения информации поставленной с модели.
Модель - отвечает за функционал: подкл. к БД, обработку к-либо данных.
Вид - отображение данных на страничке
Контроллер - связывает вид и модель между собой

.Net Core - кросс-платформенная среда выполнения для построение веб и консольных программ. программные продукты разраб. на ней могут выполняться на линукс и Мак ОС

Файл - создать - Проект - .Net Core - Web-приложение ASP.Net Core - Пустой проект(шаблон)

2 Age-------------------------------------------------------
Структура папок проекта.
Connected Services - графический интерфейс для подкл. различн. служб к программе (мож. подкл. облачное хранилище и т.п.)
Properties - различные свойства для работы проекта. 
Properties - LaunshSettings.json - прописывается локальный сервер и порт, по которому будет доступен проект/сайт
Зависимости - различные библиотеки и плагины
appsettings.json - настройки режимов запуска проекта (Debug/Release)
Program.cs - тут точка входа функция Main
Startup.cs - для различных настроек (функция Configure)

Подключение библиотек:
Решение - ПКМ - Управление пакетами NuGet для решения... - Обзор - установим 2 пакета (плагина):
1) Microsoft.AspNetCore.StaticFiles - служит для работы со статич. файлами (файлы изображений, стилей)
2) Microsoft.AspNet.Mvc -  плагин для работы с моделью MVC

Startup.cs - функция ConfigureServices - служит для регистрации модулей и плагинов в проекте
Startup.cs - функция Configure - конфигурирование подключенный модулей и плагинов


3 Age------------------------------------------------------------
Модель - класс, моделирующий какую-то сущность (Car, Category)
Интерфейсы - содержат функции, способные вытягивать информацию из классов моделей.
Файлы Mocks - классы, которые реализуют интерфейсы проекта и конструируются на основе моделей (объединяют модели и интерфейсы)
Файлы Mocks - позволяют реализовать интерфейсы, наполнит информацией модели.
Файл Mock - обычный класс. Именование файла Mock<класс_модели/интерфейса)>

4 Age-----------------------------------------------------
Все Html-шаблоны нужно хранить в папке View. В этой папке создаем еще одну папку с названием, аналогичным контроллеру. CarsController - новая папка Car. Папка Car будет содержать все Html-шаблоны, которые будут прописаны в CarsController (List.cshtml)

List.cshtml - Создать -> Представление (Вид) (вид шаблона Empty) Название файла List определяется по названию метода public ViewResult List() файла CarsController.cs (так как этот метод вызывает исполнение кода в файле List.cshtml)

C# код в файлах  cshtml выносится в виде @{C#-код }

Layout - понятие "главный шаблон" - основной, статический макет сайта, в который потом вставляются другие блоки (шаблоны)

_Layout.cshtml - @RenderBody() -  встраивает различные блоки (кода), в частности лист List.cshtml
_Layout.cshtml - это общий шаблон
_ViewStart.cshtml - отвечает за то, в какой шаблон будут встраиваться дополнительные блоки
_ViewImport - тут подключаются дополнительные файлы
List.cshtml - содержит блоки кода (встраиваются в общий _Layout.cshtml)

5 Age--------------------------------------------------
bootstrap - небольшой фреймворк разработанный компанией Твиттер, включает большой набор различных CSS и JavaScript готовых решений. Применяет к объектам стили bootstrap
1) Способ подключения - при помощи ссылок cdn: https://www.bootstrapcdn.com, подключение по ссылкам в _Layout.cshtml
 <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css"/>
2) Способ подключения Через NuGet
3) Способ подключения: скачать с сайта Compiled CSS and JS, распаковываем, копируем файл bootstrap.min.css и сохраняем в wwwroot\CSS. То же самое проделать для js (JavaScript), далее подключаем в _Layout.cshtml командой
 <link href="~/css/bootstrap.min.css" rel="stylesheet" type="text/css"/>
 
Синтаксис bootstrap:
<div class ="row mt-5 mb-4"> здается дополнительный блок
mt - merge top - 5, mb - merge bottom - 4 отступы сверху и снизу


6 Age----------------------------------------------------
Установка NuGet - 
EntityFramework 
JSON (Daniel Crenna)
Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.Tools
Microsoft.EntityFrameworkCore.SqlServer

Создание БД: (20-ая мин. 6 видео)
Вид -> Другие окна -> Консоль диспетчера пакетов,
выполнить миграцию в открывшемся снизу окне. Миграция -создает доп. файлы, которые создают таблици и т.п.в БД 
команда для миграции: add-migration initial
initial -  просто название для миграции (придумывает пользователь)
полный вид команды: EntityFrameworkCore\Add-Migration Initial
В рез-те выполнения команды создалась папка Migration, содержимое которой и послужит для создания таблиц и БД и т.п.
Закончить сборку БД можно командой: EntityFrameworkCore\Update-DataBase
Data\DBObject.cs - для добавления записей в БД

Прописываем в класс Startup, в методе Configere, добавляем метод, который будет при запуске приложения добавлять объекты в БД, по средствам вызова статического методы  DBObject.Initial()


7 Age----------------------------------------------------

EntityFrameworkCore\Add-Migration ShopCart-Add
EntityFrameworkCore\Update-DataBase

Microsoft.AspNetCore.Session
Microsoft.EntityFrameworkCore.InMemory
Microsoft.AspNetCore.Session.Http.Extensions

При установке плагинов (NuGet) их необходимо подключить в Startup.cs -> ConfigureServices(), перед подключением services.AddMvc()
кроме AddMemoryCache (его после services.AddMvc()), и, чтобы завершить добавление работы сессий, в Configure() добавляем

8 Age----------------------------------------------------

В проекте создана ветка Bonya-PC_Create_DataBase
Выполнены команды:
EntityFrameworkCore\Add-Migration Initial2\
EntityFrameworkCore\Update-DataBase
(Создание БД на новой машине)

Если кто-то столкнется, то смотрите файл Shop\Pages\_ViewStart.cshtml, у меня там стояла ссылка на  @{Layout = "_Layout"} (файл "шаблон" _Layout.cshtml), и, как только я поменял на "Index" - заработал default route Home/Index стал подгружаться при старте (https://localhost:44302/) без указания полного адреса/пути (Home/Index). 
Так же пришлось переименовать текущую страницу по умолчанию \Shop\Pages\Index.cshtml  в Index1.cshtml (иначе почему-то она пытается подтягиваться вместо той, которая для  Home делалась). Надеюсь, не слишком запутанно объяснил.

Добавляем контроллер (создаем класс унаследованный от Controller): \Shop\Controllers\
Добавляем ViewModel: Shop\ViewModels\
В папке Shop\Views\ создается вложенная папка с названием контроллера (Cars, Home, ShopCart ),
внутри папки создается файл (представление или вид) *.schtml с названием, аналогичным методу реализованному в контроллере (методу с возвращаемым значением ViewResult)

9 Age-----------------------------------------------------
Для того, чтобы открывались страницы отдельно "Главная" - лучшие автомобили (фавориты), Бензиновые - Классические автомобили и Электро - Электромобилим:

Изменяем класс CarsController, метод public ViewResult List()
добавляем входной параметр string category - входная строка с именем категории для выполнения фильтрации коллекции и вывода отфильтрованного (по категории) списка ViewResult List (то, что в конечном виде в браузере передается как /Cars/List/fuel, /Cars/List/electro, и "/" для "Лучшие" (фавориты))
public ViewResult List(string category)  == Изменение метода см. листинг ветки Age-9

10 Age----------------------------------------------------


Обновление БД:
Миграция: EntityFrameworkCore\Add-Migration Orders
Обновление: EntityFrameworkCore\Update-database

[~8:50]
В папке Repository создаются классы, которые реализуют интерфейсы.

[19:29]
Обычно ViewResult (просто определенный шаблон View)
Для OrderController создаем функцию возвращающую IActionResult (так же возвращает шаблон View, но с этим шаблоном будут происходить некие действия - в шаблоне будет распологаться форма, куда пользователь будет вводить данные)

[~23:xx]
После подключения тэг-хелпера, в HTML-блоках/классах вместо ссылок href="/car/list" можно использовать
выражения типа asp-controller="Home" asp-action="Index" - задаем, какой контроллер будет обрабатывать и какой метод.

<div class="form-group">....</div> блок, в котором помещается подпись label asp-for="name", текст ошибки и поле :
<input asp-for="name" class="form-control"/>
<span asp-validation-for="name" class="text-danger"/>
Поля, с которыми мы работаем в форме должны совпадать с моделью Order:
в форме так же необходимо реализовать поля SurName, Address, Phone, EMail (поля из модели класса Order)

<div class="col-md-5"> - блок (для красоты)

<input asp-for="Name" class="form-control"/> инпут для поля Name, эти поля автоматически подстраиваются под типы данных полей класса (Order.Name <- string)
Тэг <span asp-validation-for="Name" class="text-danger"/> - выводится, если пользователь не вводит в (форму) поле Name данные (ОШИБКА)


CarsRepository_categoryCars.AllCategories.First()

========================================================================================================
Видео 10
1.
Для странички нужно создать новую модель. В модели реализуются все необходимые поля, которые потом отображаются в новой форме (html-странице)
Data->Medels -> Add new Class Order (заказ)

public class Order
{
	public int Id {get;set;} //Id заказа, необходимое для БД
	public string Name {get;set;}
	public string SurName {get;set;}
	public string Address {get;set;}
	public string Phone {get;set;}
	public string EMail {get;set;}
	...
	public List<OrderDetail> orderDetails {get;set;} //поле на основе класса с информацией о заказе - в список помещается описание всех товаров, которые мы приобретаем (добавили в корзину)
}
2.
Data->Models -> Add new Class OrderDetails
public class OrderDetails
{
	public int Id {get;set;} //необходимое для БД
	public int OrderId {get;set;} //
	public int CarId {get;set;} //идентификатор конкретного товара
	public uint Price {get;set;}
	public virtual Car car {get;set;} //связывает список заказа (OrderDetails) с объектом товара (нужны для БД)      //помещается объект товар
	public virtual Order order {get;set;} //связывает список заказа (OrderDetails) с объектом заказа (нужны для БД)  //помещается объект заказ
	
	public List<OrderDetail> orderDetails {get;set;} //поле на основе класса с информацией о заказе - в список помещается описание всех товаров, которые мы приобретаем (добавили в корзину)
}

3. Зайти в AppDbConfig.sc и зарегистрировать две таблицы:
public DbSet<Order> Order {get;set;}
public DbSet<OrderDatails> OrderDetails {get;set;}

4. После внесения изменений в БД (шаг 3, добавление таблиц), необходимо выполнить обновление структуры БД
Вид - Другие окна - Консоль диспечтера пакетов:
EntityFrameworkCore\Add-Migration UpdateBD
EntityFrameworkCore\Update-DataBase 

Перед созданием контроллера и ШТМЛ-шаблона необходимо создать интерфейс и класс его реализующий (длянахуя??? -по воле небес???)

5. Создаем интерфейс и класс его реализующий (для чего? - да хз, так задумано всевышним...)
5.1 Date -> Interface -> Add Class -> Interface -> IAllOrders.sc ([19:12] - модификатор доступа public)
В интерфейсе всего одна функция, которая будет создавать заказ (void createOrders(Order order))
и 2 перременные: ссылка на AppDbContent и 
privete readonly AppDbContent appDbContent {get;set;};
privete readonly ShopCart shopCart {get;set;};
5.2 Создаем класс реализующий интерфейс 
Date -> Repository -> Add new Class OrdersRepository.sc (класс необходимый для БД?)
[11:02]

Далее создаем конструктор, в котором будут устанавливаться значения для наших полей (shopCart, appDbContent)
Далее реализуем метод public void createOrders(Order order): у входящего параметра Order order устанавливаем текущее время (время заказа)
Далее добавляем заказ в таблицу БД Order через ссылку appDbContent
и создаем переменную. которая будет хранить все товары, которые заказывает пользователь.
Далее создаем цикл для заполнения полей OrderDetails и добавляем объект, созданный в итерации цикла в БД.
В звыершении метода сохраняем все настройки в БД [16:50]

public class OrderRepository : IAllOrders
{
	privete readonly AppDbContent appDbContent; //для возможности добавления в таблицы БД
	privete readonly ShopCart shopCart;         //корзина с товарами для покупки (ссылка на класс)
	
	public OrderRepository (ShopCart shopCart, AppDbContent appDbContent)
	{
		this.shopCart = shopCart;
		this.appDbContent = appDbContent;
	}
	
	public void createOrders(Order order) //реализация интерфейсв IAllOrders
	{
		order.orderTime = DateTime.Now;
		appDbContent.Order.Add(order);
		
		var items = shopCar.ListShopItems; //переменная, которая хранит все товары, которые заказывает пользователь
		
		foreach(var el in items)
		{
			var orderDetails = new OrderDetaols(){ carId = el.Car.Id, orderId = order.Id, Price = el.Car.Price};
			appDbContent.OrderDetails.Add(orderDetails) // Добавляем в БД [16:46]			
		}
		appDbContent.SaveChanges(); // сохраняем изменения внесенные в БД.
	}
}

Создание контроллера [17:15]
Controllers -> Add class -> OrderController.cs
[17:45] создаем 2 переменные, которые будут обращаться: первая к интерфейсу IAllOrders (через неё обращаемся к функции создания заказа),
вторая переменная обращается к ShopCart.
[19:20] Создаем еще один метод CheckOut с возвращаемым объектом IActionResult  (возвращает некий View),
возвращает html-шаблон, над которым происходят какие-то действия - в нашем случае, возвращается форма, в которую пользователь может вводить данные [~20:05] и данные, введенные пользователем,
будут приниматься из формы блягодаря IActionResult

public class OrderController : Microsoft.AspNetCore.MVC.Controller
{
	privete readonly IAllOrders allorders; //для возможности добавления в таблицы БД
	privete readonly ShopCart shopCart;         //корзина с товарами для покупки (ссылка на класс)
	
	public OrderController (ShopCart shopCart, IAllOrders allorders)
	{
		this.shopCart = shopCart;
		this.allorders = allorders;
	}
	
	public IActionResult CheckOut() //  
	{
		retturn View();	 //возвращает html-шаблон, над которым происходят какие-то действия (IActionResult)
	}
}

[20:35] Создаем новую форму под новый контроллер
View - Add folder Order (так как наш контроллер называется OrderController) -> Add new class View CheckOut (имя CheckOut должно совпадать с названием метода из контроллера - т.е. названием метода и html-шаблон, который он вызывает/возвращает должны совпадать)
[21:12] Создание формы html-шаблона
Подключаем в шаблоне модель 
@model Order
Далее прописываем html

[22:30] Подключение TagHelpers
Нужные тэг-хелперы подключаются в файле _ViewImport.cshtml седующими командами:
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers //подключаем все тэг-хелперы из Microsoft.AspNetCore.Mvc.TagHelpers
Одна из функций тэг-хелперов в html-коде ссылки прописываются в виде href="[путь ссылки]", с использованием тэг-хелперов мы можем задавать в структуре html-кода конкретные контроллер и метод (которые указывает на необходимую форму):
<a class="nav-link" href="/">Главная</a> //без тэг-хелперов
<a class="nav-link" asp-controller="Home" asp-action="Index">Главная</a> //с тэг-хелпером --при нажатии на ссылку вызывается конроллер HomeController и метод контроллера Index (вызывающий html-шаблон Index.cshtml)
[~26:00] Описание связи полей формы с полями класса Order, который мы подключили в качестве модели в шаблон: имена формы должны полностью совпадать с именами класса
Поля Input html-шаблона автоматически подстраиваются к типу данных полей класса модели, который мы указываем (@model Order)

<input asp-form="name" class="form-control"/> -- связывается поле public string name класса Order с типом string (если бы в Order поле name было типа int - input ограничивал бы на форме поле вводом только цифрами)
<span asp-validation-for="name" class="text-danger"></span> //проверка данных вводимых в поле с именем name html формы.

Часть кода формы Checkout.cshtml
@model Order
<div class="row">
	<h3>Оформление заказа</h3>
	<form asp-action="Checkout" method="post" class="form-horizontal">
		<div class="form-group">
			<label asp-for="name"></label>
			<div class="col-md-5">
				<input asp-for="name" class="from-control"/>
				<span asp-validation-for="name" class="text-danger"></span>
			</div>
		</div>
		//остальные поля модели (класса) Order (surname, address, phone, email), реализуются тким же образом (Ctrl+C, Ctrl+V, rename)
		...
		...
		...
		//кнопка с типом submit, которая вызовет asp-action="Checkout" (именно при нажатии на кнопку с типом данных submit у нас будет срабатывать экшин asp-action="Checkout" которая будет вызывать 
		//функцию  Checkout)
		<input class="btn btn-success" type="submit" value="Завершить заказ"/>
	</form>

начиная после 30 минуты

[~32:15]<a></a> -- ссылка (кнопка class="btn btn-success" работает только с ссылкой или с input, но не div (синтаксис хелперов работает в ссылках и в инпутах, но не в div))
[32:45] InvalidOperationException: Unable to resolve service for type 'Shop.Data.Interfaces.IAllOrders' while attempting to active Shop.Controllers.OrderController == необходимо зарегистрировать интерфейс IAllOrders в сервисах/зависимостях
в классе Startup, методе ConfigureServices
services.AddTransient<IAllOrders, OrdersRepository>();

[33:50] проблема с добавлением товаров в корзину
AllCars.cshtml
меняем
@model Car
...
...
...
<p><a class="btn-warning" asp-controller="ShopCart" asp-action="AddToCart" asp-route-carId="@Model.Id">Добавить в корзину</a></p>
на
<p><a class="btn-warning" asp-controller="ShopCart" asp-action="addToCart" asp-route-carId="@Model.Id">Добавить в корзину</a></p>
имя функции было указано не верно (с большой буквы)

Метод контроллера addToCart(int id) производит вызов функции из модели (класса ShopCart) с добавлением самого товара в корзину
_shopCart.AddToCar(item);

Чтобы передать int id из метода addToCart в форму AllCars.cshtml, необходимо поменять asp-route-carId на asp-route-Id - по названию параметра в методе - int id (если бы параметр в методе назывался carId, то и в asp-route прописывался бы asp-route-carId):
<p><a class="btn-warning" asp-controller="ShopCart" asp-action="addToCart" asp-route-carId="@Model.Id">Добавить в корзину</a></p>
на
<p><a class="btn-warning" asp-controller="ShopCart" asp-action="addToCart" asp-route-Id="@Model.Id">Добавить в корзину</a></p> 

Валидация данных формы для ввода
[37:00] изменение модели Order для реализации проверки вводимых значений в форме Checkout.cshtml (Покупка)
(новые добавленные поля - с комментариями)
подключяем в классе библиотеку: Microsoft.AspNetCore.Mvcю.ModelBinding
using System.ComponentModel.DataAnnotations; //[Display(Name = "Введите имя")], [StringLength(2)]
using Microsoft.AspNetCore.Mvc.ModelBinding; //[Required(ErrorMessage = "Длина имени не менее 2 символов")], [BindNever]

public class Order
    {
		[BindNever]// аттрибут указывает, что данное поле никогда не будет отображаться на странице (дословно "никогда не привязывать")
        public int Id { get; set; }
		
		[Display(name = "Введите имя")] 
		[StringLength(2)] //Проверка, что вводимое значение не должно быть меньше 2 символов (имя Ян)
		[Reqiured(ErrorMessage="Длина имени не менее 2 символов")] // если меньше 2 символов - выдается сообщение
        public string Name { get; set; }
		
		[Display(name = "Фамилия")] 
		[StringLength(2)] //Проверка, что вводимое значение не должно быть меньше 2 символов (фамилия Ли)
		[Reqiured(ErrorMessage="Длина фамилии не менее 2 символов")] // если меньше 2 символов - выдается сообщение
        public string SurName { get; set; }
		
		[Display(name = "Адрес")] 
		[StringLength(15)] //Проверка, что вводимое значение не должно быть меньше 15 символов
		[Reqiured(ErrorMessage="Длина адреса не менее 15 символов")] // если меньше 15 символов - выдается сообщение
        public string Address { get; set; }
		
		[Display(name = "Телефон")] 
		[DataType(DataType.PhoneNumber)]
		[StringLength(11)] //Проверка, что вводимое значение не должно быть меньше 11 символов
		[Reqiured(ErrorMessage="Длина номера телефона не менее 11 символов")] // если меньше 11 символов - выдается сообщение
        public string Phone { get; set; }
		
		[Display(name = "EMail")] 
		[DataType(DataType.EmailAddress)]
		[StringLength(5)] //Проверка, что вводимое значение не должно быть меньше 5символов
		[Reqiured(ErrorMessage="Длина электронного адреса не менее 5 символов")] // если меньше  5 символов - выдается сообщение
        public string EMail { get; set; }
		
		
		[BindNever]
		[ScaffoldColumn(false)] //для того, чтобы не просто скрыть данное поле, но чтобы оно не было отображено в исходном коде (чтобы это ни значило)
        public DateTime OrderTime { get; set; }

        public List<OrderDetails> OrderDetails { get; set; }

    }

[~41:10] Изменение функции контроллера OrderController, public IActionResult Checkout()

public IActionResult Checkout() //данная функция будет вызвана, когда мы перейдем на страничку заказа, но при этом мы еще не отправляли данные
{
	return View();
}

[HttpPost] //функция, которая срабатывает только при HttpPost - т.е., когда мы заполнили поля формы и нажали подтвердить заказ, 
		   //значеие полей формы передаются в программу (asp-actions="Checkout" method="post" )
public IActionResult Checkout(Order order) //данная функция будет вызвана, когда мы перейдем на страничку заказа, но при этом мы еще не отправляли данные
{
	shopCart.ListShopItems = shopCart.getShopItems();
	if(_ShopCart.ListShopItems.Count == 0) // если товаров в корзине нет еще
	{
		ModelState.AddModelError("", "У вас дожны быть товары!"); // ключ и значение (в нашем случае ключ пустой)
	}
	Else
	{
[45:31] if(ModelState.IsValid) //вернет true только в том случае, если все поля формы, заполненные пользователем прошли проверку
		{
			allOrders.createOrder(order);
			return RedirectToAction("Complete") //если все в порядке, то возвращаем нужную страницу редиректом (перенаправляем на нужную страницу)
		}
	}
	return View();
}

[47:10] Создаем функцию Complete в контроллере OrderController 

public IActionResult Complete() 
{
	ViewBag.Message = "Заказ успешно обработан!";
    return View();
}
[47:50]	Views -> Order	-> Add new View Complete.cshtml

[49:00]Ошибка=========================
Microsoft.EntityFrameworkCore.DbUpdateException: "An error occurred while updating the entries. See the inner exception for details."

SqlException: The INSERT statement conflicted with the FOREIGN KEY constraint "FK_OrderDetails_Car_CarId". The conflict occurred in database "Shop", table "dbo.Car", column 'Id'.
The statement has been terminated.
===============================
